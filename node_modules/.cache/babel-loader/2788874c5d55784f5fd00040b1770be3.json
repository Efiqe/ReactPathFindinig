{"ast":null,"code":"const visited = [];\n\nfunction Node(x, y) {\n  this.x = x;\n  this.y = y;\n  this.searched = false;\n}\n\nconst findNeighbors = (grid, cord) => {\n  let neighbors = []; //Nahoru\n\n  if (cord[0] + 1 < grid.length) {\n    neighbors.push([cord[0] + 1, cord[1]]);\n  } //Dolu\n\n\n  if (cord[0] - 1 >= 0) {\n    neighbors.push([cord[0] - 1, cord[1]]);\n  } //Doleva\n\n\n  if (cord[1] - 1 >= 0) {\n    neighbors.push([cord[0], cord[1] - 1]);\n  } //Doprava\n\n\n  if (cord[1] + 1 < grid[0].length) {\n    neighbors.push([cord[0], cord[1] + 1]);\n  }\n\n  fillNeighbors(neighbors);\n  return neighbors;\n};\n\nconst fillNeighbors = neigh => {\n  neigh.forEach((el, idx, arr) => {\n    // console.log(el[0])\n    let x = el[0];\n    let y = el[1];\n    arr[idx] = new Node(x, y);\n  });\n};\n\nexport const BFS = (grid, start, end) => {\n  let queue = [];\n  start.searched = true;\n  queue.push(start);\n  let dict = {};\n\n  while (queue.length > 0) {\n    let current = queue.shift();\n    visited.push(current);\n\n    if (current === end) {\n      console.log(\"Found\");\n      break;\n    } else {\n      let neighbors = findNeighbors(grid, [current.x, current.y]);\n      neighbors.forEach(el => {\n        let mem = grid[el.x][el.y];\n\n        if (grid[el.x][el.y].searched === false) {\n          mem.searched = true;\n          queue.push(mem);\n          dict[[el.y, el.x]] = [current.y, current.x];\n        }\n\n        ;\n      });\n    }\n  }\n\n  ;\n  return dict;\n};\nexport const showPath = (dict, start, end) => {\n  let curPos = end;\n  const result = [];\n\n  while (!equal(curPos, start)) {\n    result.push(curPos);\n    curPos = dict[curPos]; // console.log(result)\n  }\n\n  result.push(start);\n  return result;\n};","map":{"version":3,"sources":["/home/vojta-pc/Documents/FrontEnd/PathfindingBeta/pathfindinfbeta/src/components/Bfs.js"],"names":["visited","Node","x","y","searched","findNeighbors","grid","cord","neighbors","length","push","fillNeighbors","neigh","forEach","el","idx","arr","BFS","start","end","queue","dict","current","shift","console","log","mem","showPath","curPos","result","equal"],"mappings":"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","sourcesContent":["const visited = [];\n\nfunction Node(x, y) {\n    this.x = x;\n    this.y = y;\n    this.searched = false;\n}\n\nconst findNeighbors = (grid, cord) => {\n    let neighbors = [];\n\n    //Nahoru\n    if (cord[0] + 1 < grid.length) {\n        neighbors.push([cord[0] + 1, cord[1]])\n    }\n\n    //Dolu\n    if (cord[0] - 1 >= 0) {\n        neighbors.push([cord[0] - 1, cord[1]])\n    }\n\n    //Doleva\n    if (cord[1] - 1 >= 0) {\n        neighbors.push([cord[0], cord[1] - 1])\n    }\n\n    //Doprava\n    if (cord[1] + 1 < grid[0].length) {\n        neighbors.push([cord[0], cord[1] + 1])\n    }\n\n    fillNeighbors(neighbors);\n\n    return neighbors;\n}\n\nconst fillNeighbors = (neigh) => {\n    neigh.forEach((el, idx, arr) => {\n        // console.log(el[0])\n        let x = el[0];\n        let y = el[1];\n        arr[idx] = new Node(x, y);\n    });\n};\n\nexport const BFS = (grid, start, end) => {\n    let queue = []\n    start.searched = true\n    queue.push(start)\n    let dict = {};\n\n    while (queue.length > 0) {\n        let current = queue.shift();\n        visited.push(current);\n\n        if (current === end) {\n            console.log(\"Found\");\n            break;\n        } else {\n\n            let neighbors = findNeighbors(grid, [current.x, current.y])\n\n\n            neighbors.forEach(el => {\n                let mem = grid[el.x][el.y];\n                if (grid[el.x][el.y].searched === false) {\n                    mem.searched = true;\n                    queue.push(mem);\n                    dict[[el.y, el.x]] = [current.y, current.x];\n                };\n            });\n        }\n    };\n\n    return dict;\n};\n\nexport const showPath = (dict, start, end) => {\n    let curPos = end;\n    const result = [];\n\n    while (!equal(curPos, start)) {\n        result.push(curPos);\n        curPos = dict[curPos];\n        // console.log(result)\n    }\n\n    result.push(start);\n\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}