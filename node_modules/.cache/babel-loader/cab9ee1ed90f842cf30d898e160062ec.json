{"ast":null,"code":"const path = [];\n\nconst findNeighbors = (grid, cord) => {\n  let neighbors = []; //Nahoru\n\n  if (cord[0] + 1 < grid.length) {\n    neighbors.push([cord[0] + 1, cord[1]]);\n  } //Dolu\n\n\n  if (cord[0] - 1 >= 0) {\n    neighbors.push([cord[0] - 1, cord[1]]);\n  } //Doleva\n\n\n  if (cord[1] - 1 >= 0) {\n    neighbors.push([cord[0], cord[1] - 1]);\n  } //Doprava\n\n\n  if (cord[1] + 1 < grid[0].length) {\n    neighbors.push([cord[0], cord[1] + 1]);\n  }\n\n  fillNeighbors(neighbors);\n  return neighbors;\n};\n\nconst fillNeighbors = neigh => {\n  neigh.forEach((el, idx, arr) => {\n    // console.log(el[0])\n    let x = el[0];\n    let y = el[1];\n    arr[idx] = new Spot(x, y);\n  });\n};\n\nexport const BFS = (grid, start, end) => {\n  let queue = [];\n  start.searched = true;\n  queue.push(start);\n\n  while (queue.length > 0) {\n    let current = queue.shift();\n    path.push(current);\n\n    if (current === end) {\n      console.log(\"Found\");\n      break;\n    }\n\n    ;\n    let neighbors = findNeighbors(grid, [current.x, current.y]);\n    neighbors.forEach(el => {\n      let mem = grid[el.x][el.y];\n\n      if (grid[el.x][el.y].searched === false && grid[el.x][el.y].isWall === false) {\n        mem.searched = true;\n        queue.push(mem);\n      }\n\n      ;\n    });\n  }\n\n  ;\n};","map":{"version":3,"sources":["/home/vojta-pc/Documents/FrontEnd/PathfindingBeta/pathfindinfbeta/src/components/Bfs.js"],"names":["path","findNeighbors","grid","cord","neighbors","length","push","fillNeighbors","neigh","forEach","el","idx","arr","x","y","Spot","BFS","start","end","queue","searched","current","shift","console","log","mem","isWall"],"mappings":"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","sourcesContent":["const path = [];\n\nconst findNeighbors = (grid, cord) => {\n    let neighbors = [];\n\n    //Nahoru\n    if (cord[0] + 1 < grid.length) {\n        neighbors.push([cord[0] + 1, cord[1]])\n    }\n\n    //Dolu\n    if (cord[0] - 1 >= 0) {\n        neighbors.push([cord[0] - 1, cord[1]])\n    }\n\n    //Doleva\n    if (cord[1] - 1 >= 0) {\n        neighbors.push([cord[0], cord[1] - 1])\n    }\n\n    //Doprava\n    if (cord[1] + 1 < grid[0].length) {\n        neighbors.push([cord[0], cord[1] + 1])\n    }\n\n    fillNeighbors(neighbors);\n\n    return neighbors;\n}\n\nconst fillNeighbors = (neigh) => {\n    neigh.forEach((el, idx, arr) => {\n        // console.log(el[0])\n        let x = el[0];\n        let y = el[1];\n        arr[idx] = new Spot(x, y);\n    });\n};\n\nexport const BFS = (grid, start, end) => {\n    let queue = []\n    start.searched = true\n    queue.push(start)\n\n\n    while (queue.length > 0) {\n        let current = queue.shift();\n        path.push(current);\n        if (current === end) {\n            console.log(\"Found\");\n            break;\n        };\n\n        let neighbors = findNeighbors(grid, [current.x, current.y])\n\n\n        neighbors.forEach(el => {\n            let mem = grid[el.x][el.y];\n            if (grid[el.x][el.y].searched === false && grid[el.x][el.y].isWall === false) {\n                mem.searched = true;\n                queue.push(mem);\n            };\n        });\n    };\n\n};\n"]},"metadata":{},"sourceType":"module"}