{"ast":null,"code":"const visited = [];\nlet path = [];\n\nfunction Spot(x, y) {\n  this.x = x;\n  this.y = y;\n  this.searched = false;\n  this.isPath = false;\n}\n\nconst findNeighbors = (grid, cord) => {\n  let neighbors = []; //Nahoru\n\n  if (cord[0] + 1 < grid.length) {\n    neighbors.push([cord[0] + 1, cord[1]]);\n  } //Dolu\n\n\n  if (cord[0] - 1 >= 0) {\n    neighbors.push([cord[0] - 1, cord[1]]);\n  } //Doleva\n\n\n  if (cord[1] - 1 >= 0) {\n    neighbors.push([cord[0], cord[1] - 1]);\n  } //Doprava\n\n\n  if (cord[1] + 1 < grid[0].length) {\n    neighbors.push([cord[0], cord[1] + 1]);\n  }\n\n  fillNeighbors(neighbors);\n  return neighbors;\n};\n\nconst fillNeighbors = neigh => {\n  neigh.forEach((el, idx, arr) => {\n    // console.log(el[0])\n    let x = el[0];\n    let y = el[1];\n    arr[idx] = new Spot(x, y);\n  });\n};\n\nexport const BFS = (grid, start, end) => {\n  let queue = [];\n  start.searched = true;\n  queue.push(start);\n\n  while (queue.length > 0) {\n    let current = queue.shift();\n    visited.push(current);\n\n    if (current === end) {\n      console.log(\"Found\");\n      break;\n    } else {\n      let neighbors = findNeighbors(grid, [current.x, current.y]);\n      neighbors.forEach(el => {\n        let mem = grid[el.x][el.y];\n\n        if (grid[el.x][el.y].searched === false) {\n          mem.searched = true;\n          queue.push(mem);\n        }\n\n        ;\n      });\n    }\n  }\n\n  ;\n  console.log(path);\n  path.push(queue.pop());\n  path.forEach(el => {\n    let mem = grid[el.x][el.y];\n\n    if (grid[el.x][el.y].path === false) {\n      mem.path = true;\n    }\n  });\n};","map":{"version":3,"sources":["/home/vojta-pc/Documents/FrontEnd/PathfindingBeta/pathfindinfbeta/src/components/Bfs.js"],"names":["visited","path","Spot","x","y","searched","isPath","findNeighbors","grid","cord","neighbors","length","push","fillNeighbors","neigh","forEach","el","idx","arr","BFS","start","end","queue","current","shift","console","log","mem","pop"],"mappings":"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","sourcesContent":["const visited = [];\nlet path = [];\n\nfunction Spot(x, y) {\n    this.x = x;\n    this.y = y;\n    this.searched = false;\n    this.isPath = false;\n}\n\nconst findNeighbors = (grid, cord) => {\n    let neighbors = [];\n\n    //Nahoru\n    if (cord[0] + 1 < grid.length) {\n        neighbors.push([cord[0] + 1, cord[1]])\n    }\n\n    //Dolu\n    if (cord[0] - 1 >= 0) {\n        neighbors.push([cord[0] - 1, cord[1]])\n    }\n\n    //Doleva\n    if (cord[1] - 1 >= 0) {\n        neighbors.push([cord[0], cord[1] - 1])\n    }\n\n    //Doprava\n    if (cord[1] + 1 < grid[0].length) {\n        neighbors.push([cord[0], cord[1] + 1])\n    }\n\n    fillNeighbors(neighbors);\n\n    return neighbors;\n}\n\nconst fillNeighbors = (neigh) => {\n    neigh.forEach((el, idx, arr) => {\n        // console.log(el[0])\n        let x = el[0];\n        let y = el[1];\n        arr[idx] = new Spot(x, y);\n    });\n};\n\nexport const BFS = (grid, start, end) => {\n    let queue = []\n    start.searched = true\n    queue.push(start)\n\n\n    while (queue.length > 0) {\n        let current = queue.shift();\n        visited.push(current);\n        if (current === end) {\n            console.log(\"Found\");\n            break;\n        } else {\n\n            let neighbors = findNeighbors(grid, [current.x, current.y])\n\n\n            neighbors.forEach(el => {\n                let mem = grid[el.x][el.y];\n                if (grid[el.x][el.y].searched === false) {\n                    mem.searched = true;\n                    queue.push(mem);\n                };\n            });\n        }\n    };\n    console.log(path)\n\n    path.push(queue.pop())\n\n    path.forEach((el) => {\n        let mem = grid[el.x][el.y];\n        if (grid[el.x][el.y].path === false) {\n            mem.path = true;\n        }\n    })\n};\n"]},"metadata":{},"sourceType":"module"}