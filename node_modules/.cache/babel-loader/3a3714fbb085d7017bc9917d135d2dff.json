{"ast":null,"code":"const visited = [];\n\nfunction Node(x, y) {\n  this.x = x;\n  this.y = y;\n  this.searched = false;\n}\n\nfunction equal(a, b) {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n\n  for (var i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n}\n\nconst findNeighbors = (grid, cord) => {\n  let neighbors = []; //Nahoru\n\n  if (cord[0] + 1 < grid.length) {\n    neighbors.push([cord[0] + 1, cord[1]]);\n  } //Dolu\n\n\n  if (cord[0] - 1 >= 0) {\n    neighbors.push([cord[0] - 1, cord[1]]);\n  } //Doleva\n\n\n  if (cord[1] - 1 >= 0) {\n    neighbors.push([cord[0], cord[1] - 1]);\n  } //Doprava\n\n\n  if (cord[1] + 1 < grid[0].length) {\n    neighbors.push([cord[0], cord[1] + 1]);\n  }\n\n  fillNeighbors(neighbors);\n  return neighbors;\n};\n\nconst fillNeighbors = neigh => {\n  neigh.forEach((el, idx, arr) => {\n    // console.log(el[0])\n    let x = el[0];\n    let y = el[1];\n    arr[idx] = new Node(x, y);\n  });\n};\n\nexport const BFS = (grid, start, end) => {\n  let queue = [];\n  start.searched = true;\n  queue.push(start);\n  let dict = {};\n\n  while (queue.length > 0) {\n    let current = queue.shift();\n    visited.push(current);\n\n    if (current === end) {\n      console.log(\"Found\");\n      break;\n    } else {\n      let neighbors = findNeighbors(grid, [current.x, current.y]);\n      neighbors.forEach(el => {\n        let mem = grid[el.x][el.y];\n\n        if (grid[el.x][el.y].searched === false) {\n          mem.searched = true;\n          queue.push(mem);\n          dict[[el.y, el.x]] = [current.y, current.x];\n        }\n\n        ;\n      });\n    }\n  }\n\n  ;\n  return dict;\n};\nexport const showPath = (dict, start, end) => {\n  let curPos = end;\n  const result = [];\n\n  while (!equal(curPos, start)) {\n    result.push(curPos);\n    curPos = dict[curPos]; // console.log(result)\n  }\n\n  result.push(start);\n  return result;\n};","map":{"version":3,"sources":["/home/vojta-pc/Documents/FrontEnd/PathfindingBeta/pathfindinfbeta/src/components/Bfs.js"],"names":["visited","Node","x","y","searched","equal","a","b","length","i","findNeighbors","grid","cord","neighbors","push","fillNeighbors","neigh","forEach","el","idx","arr","BFS","start","end","queue","dict","current","shift","console","log","mem","showPath","curPos","result"],"mappings":"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","sourcesContent":["const visited = [];\n\nfunction Node(x, y) {\n    this.x = x;\n    this.y = y;\n    this.searched = false;\n}\n\nfunction equal(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length !== b.length) return false;\n\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n\nconst findNeighbors = (grid, cord) => {\n    let neighbors = [];\n\n    //Nahoru\n    if (cord[0] + 1 < grid.length) {\n        neighbors.push([cord[0] + 1, cord[1]])\n    }\n\n    //Dolu\n    if (cord[0] - 1 >= 0) {\n        neighbors.push([cord[0] - 1, cord[1]])\n    }\n\n    //Doleva\n    if (cord[1] - 1 >= 0) {\n        neighbors.push([cord[0], cord[1] - 1])\n    }\n\n    //Doprava\n    if (cord[1] + 1 < grid[0].length) {\n        neighbors.push([cord[0], cord[1] + 1])\n    }\n\n    fillNeighbors(neighbors);\n\n    return neighbors;\n}\n\nconst fillNeighbors = (neigh) => {\n    neigh.forEach((el, idx, arr) => {\n        // console.log(el[0])\n        let x = el[0];\n        let y = el[1];\n        arr[idx] = new Node(x, y);\n    });\n};\n\nexport const BFS = (grid, start, end) => {\n    let queue = []\n    start.searched = true\n    queue.push(start)\n    let dict = {};\n\n    while (queue.length > 0) {\n        let current = queue.shift();\n        visited.push(current);\n\n        if (current === end) {\n            console.log(\"Found\");\n            break;\n        } else {\n\n            let neighbors = findNeighbors(grid, [current.x, current.y])\n\n\n            neighbors.forEach(el => {\n                let mem = grid[el.x][el.y];\n                if (grid[el.x][el.y].searched === false) {\n                    mem.searched = true;\n                    queue.push(mem);\n                    dict[[el.y, el.x]] = [current.y, current.x];\n                };\n            });\n        }\n    };\n\n    return dict;\n};\n\nexport const showPath = (dict, start, end) => {\n    let curPos = end;\n    const result = [];\n\n    while (!equal(curPos, start)) {\n        result.push(curPos);\n        curPos = dict[curPos];\n        // console.log(result)\n    }\n\n    result.push(start);\n\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}