{"ast":null,"code":"const visited = [];\n\nfunction Node(y, x) {\n  this.y = y;\n  this.x = x;\n  this.searched = false;\n} // Warn if overriding existing method\n\n\nif (Array.prototype.equals) console.warn(\"Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.\"); // attach the .equals method to Array's prototype to call it on any array\n\nArray.prototype.equals = function (array) {\n  // if the other array is a falsy value, return\n  if (!array) return false; // compare lengths - can save a lot of time \n\n  if (this.length != array.length) return false;\n\n  for (var i = 0, l = this.length; i < l; i++) {\n    // Check if we have nested arrays\n    if (this[i] instanceof Array && array[i] instanceof Array) {\n      // recurse into the nested arrays\n      if (!this[i].equals(array[i])) return false;\n    } else if (this[i] != array[i]) {\n      // Warning - two different object instances will never be equal: {x:20} != {x:20}\n      return false;\n    }\n  }\n\n  return true;\n}; // Hide method from for-in loops\n\n\nObject.defineProperty(Array.prototype, \"equals\", {\n  enumerable: false\n});\n\nconst findNeighbors = (grid, cord) => {\n  let neighbors = []; //Nahoru\n\n  if (cord[0] + 1 < grid.length) {\n    neighbors.push([cord[0] + 1, cord[1]]);\n  } //Dolu\n\n\n  if (cord[0] - 1 >= 0) {\n    neighbors.push([cord[0] - 1, cord[1]]);\n  } //Doleva\n\n\n  if (cord[1] - 1 >= 0) {\n    neighbors.push([cord[0], cord[1] - 1]);\n  } //Doprava\n\n\n  if (cord[1] + 1 < grid[0].length) {\n    neighbors.push([cord[0], cord[1] + 1]);\n  }\n\n  fillNeighbors(neighbors);\n  return neighbors;\n};\n\nconst fillNeighbors = neigh => {\n  neigh.forEach((el, idx, arr) => {\n    // console.log(el[0])\n    let y = el[0];\n    let x = el[1];\n    arr[idx] = new Node(y, x);\n  });\n};\n\nexport const BFS = (grid, start, end) => {\n  let queue = [];\n  start.searched = true;\n  queue.push(start);\n  let dict = {};\n\n  while (queue.length > 0) {\n    let current = queue.shift();\n    visited.push(current);\n\n    if (current === end) {\n      console.log(\"Found\"); // console.log(dict)\n\n      break;\n    } else {\n      let neighbors = findNeighbors(grid, [current.y, current.x]);\n      neighbors.forEach(el => {\n        let mem = grid[el.y][el.x];\n\n        if (grid[el.y][el.x].searched === false) {\n          mem.searched = true;\n          queue.push(mem);\n          dict[[el.y, el.x]] = [current.y, current.x];\n        }\n\n        ;\n      });\n    }\n  }\n\n  ;\n  return dict;\n};\nexport const showPath = (dict, start, end) => {\n  let curPos = end;\n  const result = []; // console.log(dict);\n\n  console.log(start.y);\n  console.log(start.x);\n  console.log(curPos.y);\n  console.log(curPos.x);\n\n  while (![curPos.y, curPos.x].equals([start.y, start.x])) {\n    result.push(curPos);\n    curPos = dict[curPos];\n  } // result.push(start);\n\n\n  return result;\n};","map":{"version":3,"sources":["/home/vojta-pc/Documents/FrontEnd/PathfindingBeta/pathfindinfbeta/src/components/Bfs.js"],"names":["visited","Node","y","x","searched","Array","prototype","equals","console","warn","array","length","i","l","Object","defineProperty","enumerable","findNeighbors","grid","cord","neighbors","push","fillNeighbors","neigh","forEach","el","idx","arr","BFS","start","end","queue","dict","current","shift","log","mem","showPath","curPos","result"],"mappings":"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","sourcesContent":["const visited = [];\n\nfunction Node(y, x) {\n    this.y = y;\n    this.x = x;\n    this.searched = false;\n}\n\n// Warn if overriding existing method\nif (Array.prototype.equals)\n    console.warn(\"Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.\");\n// attach the .equals method to Array's prototype to call it on any array\nArray.prototype.equals = function (array) {\n    // if the other array is a falsy value, return\n    if (!array)\n        return false;\n\n    // compare lengths - can save a lot of time \n    if (this.length != array.length)\n        return false;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n        // Check if we have nested arrays\n        if (this[i] instanceof Array && array[i] instanceof Array) {\n            // recurse into the nested arrays\n            if (!this[i].equals(array[i]))\n                return false;\n        }\n        else if (this[i] != array[i]) {\n            // Warning - two different object instances will never be equal: {x:20} != {x:20}\n            return false;\n        }\n    }\n    return true;\n}\n// Hide method from for-in loops\nObject.defineProperty(Array.prototype, \"equals\", { enumerable: false });\n\n\nconst findNeighbors = (grid, cord) => {\n    let neighbors = [];\n\n    //Nahoru\n    if (cord[0] + 1 < grid.length) {\n        neighbors.push([cord[0] + 1, cord[1]])\n    }\n\n    //Dolu\n    if (cord[0] - 1 >= 0) {\n        neighbors.push([cord[0] - 1, cord[1]])\n    }\n\n    //Doleva\n    if (cord[1] - 1 >= 0) {\n        neighbors.push([cord[0], cord[1] - 1])\n    }\n\n    //Doprava\n    if (cord[1] + 1 < grid[0].length) {\n        neighbors.push([cord[0], cord[1] + 1])\n    }\n\n    fillNeighbors(neighbors);\n\n    return neighbors;\n}\n\nconst fillNeighbors = (neigh) => {\n    neigh.forEach((el, idx, arr) => {\n        // console.log(el[0])\n        let y = el[0];\n        let x = el[1];\n        arr[idx] = new Node(y, x);\n    });\n};\n\nexport const BFS = (grid, start, end) => {\n    let queue = []\n    start.searched = true\n    queue.push(start)\n    let dict = {};\n\n    while (queue.length > 0) {\n        let current = queue.shift();\n        visited.push(current);\n\n        if (current === end) {\n            console.log(\"Found\");\n            // console.log(dict)\n            break;\n        } else {\n\n            let neighbors = findNeighbors(grid, [current.y, current.x])\n\n\n            neighbors.forEach(el => {\n                let mem = grid[el.y][el.x];\n                if (grid[el.y][el.x].searched === false) {\n                    mem.searched = true;\n                    queue.push(mem);\n                    dict[[el.y, el.x]] = [current.y, current.x];\n                };\n            });\n        }\n    };\n\n    return dict;\n};\n\nexport const showPath = (dict, start, end) => {\n    let curPos = end;\n    const result = [];\n\n    // console.log(dict);\n    console.log(start.y);\n    console.log(start.x);\n\n    console.log(curPos.y);\n    console.log(curPos.x);\n\n    while (![curPos.y, curPos.x].equals([start.y, start.x])) {\n        result.push(curPos);\n        curPos = dict[curPos];\n    }\n\n    // result.push(start);\n\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}