{"ast":null,"code":"var _jsxFileName = \"/home/vojta-pc/Documents/FrontEnd/PathfindingBeta/pathfindinfbeta/src/components/Bfs.js\";\nimport React from 'react';\n\nfunction Bfs({\n  cols,\n  rows\n}) {\n  const grid = [];\n  const path = [];\n\n  function Node(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  ;\n\n  const createGrid = () => {\n    for (let i = 0; i < rows; i++) {\n      grid[i] = new Array();\n\n      for (let j = 0; j < cols; j++) {\n        grid[i][j] = new Node(i, j);\n      }\n    }\n\n    return grid;\n  };\n\n  const findNeighbors = (grid, cord) => {\n    let neighbors = []; //Nahoru\n\n    if (cord[0] + 1 < grid.length) {\n      neighbors.push([cord[0] + 1, cord[1]]);\n    } //Dolu\n\n\n    if (cord[0] - 1 >= 0) {\n      neighbors.push([cord[0] - 1, cord[1]]);\n    } //Doleva\n\n\n    if (cord[1] - 1 >= 0) {\n      neighbors.push([cord[0], cord[1] - 1]);\n    } //Doprava\n\n\n    if (cord[1] + 1 < grid[0].length) {\n      neighbors.push([cord[0], cord[1] + 1]);\n    }\n\n    fillNeighbors(neighbors);\n    return neighbors;\n  };\n\n  const fillNeighbors = neigh => {\n    neigh.forEach((el, idx, arr) => {\n      // console.log(el[0])\n      let x = el[0];\n      let y = el[1];\n      arr[idx] = new Node(x, y);\n    });\n  };\n\n  createGrid();\n  const start = grid[0][0];\n  const end = grid[1][1];\n\n  const BFS = (grid, start) => {\n    let queue = [];\n    start.searched = true;\n    queue.push(start);\n\n    while (queue.length > 0) {\n      let current = queue.shift();\n      path.push(current);\n\n      if (current === end) {\n        console.log(\"Found\");\n        break;\n      }\n\n      ;\n      let neighbors = findNeighbors(grid, [current.x, current.y]);\n      neighbors.forEach(el => {\n        let mem = grid[el.x][el.y];\n\n        if (grid[el.x][el.y].searched === false && grid[el.x][el.y].isWall === false) {\n          mem.searched = true;\n          queue.push(mem);\n        }\n\n        ;\n      });\n    }\n\n    ;\n  };\n\n  BFS(grid, start);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 98,\n      columnNumber: 9\n    }\n  });\n}\n\nexport default Bfs;","map":{"version":3,"sources":["/home/vojta-pc/Documents/FrontEnd/PathfindingBeta/pathfindinfbeta/src/components/Bfs.js"],"names":["React","Bfs","cols","rows","grid","path","Node","x","y","createGrid","i","Array","j","findNeighbors","cord","neighbors","length","push","fillNeighbors","neigh","forEach","el","idx","arr","start","end","BFS","queue","searched","current","shift","console","log","mem","isWall"],"mappings":"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","sourcesContent":["import React from 'react'\n\n\n\nfunction Bfs({ cols, rows }) {\n    const grid = [];\n    const path = [];\n\n    function Node(x, y) {\n        this.x = x;\n        this.y = y;\n    };\n\n    const createGrid = () => {\n        for (let i = 0; i < rows; i++) {\n            grid[i] = new Array();\n            for (let j = 0; j < cols; j++) {\n                grid[i][j] = new Node(i, j);\n            }\n        }\n\n        return grid;\n    }\n\n    const findNeighbors = (grid, cord) => {\n        let neighbors = [];\n\n        //Nahoru\n        if (cord[0] + 1 < grid.length) {\n            neighbors.push([cord[0] + 1, cord[1]])\n        }\n\n        //Dolu\n        if (cord[0] - 1 >= 0) {\n            neighbors.push([cord[0] - 1, cord[1]])\n        }\n\n        //Doleva\n        if (cord[1] - 1 >= 0) {\n            neighbors.push([cord[0], cord[1] - 1])\n        }\n\n        //Doprava\n        if (cord[1] + 1 < grid[0].length) {\n            neighbors.push([cord[0], cord[1] + 1])\n        }\n\n        fillNeighbors(neighbors);\n\n        return neighbors;\n    };\n\n    const fillNeighbors = (neigh) => {\n        neigh.forEach((el, idx, arr) => {\n            // console.log(el[0])\n            let x = el[0];\n            let y = el[1];\n            arr[idx] = new Node(x, y);\n        });\n    };\n\n    createGrid();\n\n    const start = grid[0][0]\n    const end = grid[1][1]\n\n    const BFS = (grid, start) => {\n        let queue = []\n        start.searched = true\n        queue.push(start)\n\n\n        while (queue.length > 0) {\n            let current = queue.shift();\n            path.push(current);\n            if (current === end) {\n                console.log(\"Found\");\n                break;\n            };\n\n            let neighbors = findNeighbors(grid, [current.x, current.y])\n\n\n            neighbors.forEach(el => {\n                let mem = grid[el.x][el.y];\n                if (grid[el.x][el.y].searched === false && grid[el.x][el.y].isWall === false) {\n                    mem.searched = true;\n                    queue.push(mem);\n                };\n            });\n        };\n\n    };\n\n    BFS(grid, start);\n\n    return (\n        <div>\n\n        </div>\n    )\n}\n\nexport default Bfs\n"]},"metadata":{},"sourceType":"module"}