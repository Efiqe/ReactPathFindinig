{"version":3,"sources":["components/Node.jsx","Algorithms/Bfs.js","Algorithms/Dijkstra.js","Algorithms/Astar.js","components/Pathfind.jsx","App.jsx","index.js"],"names":["Node","isStart","isEnd","isPath","searched","row","col","isWall","surfaceType","classes","draggAble","id","onDrop","e","preventDefault","onDragOver","dataTransfer","setData","target","className","draggable","onDragStart","equal","a","b","length","i","QElement","element","priority","this","PriorityQueue","items","qElement","contain","splice","push","isEmpty","shift","heuristic","goal","current","Math","abs","y","x","wall","sand","sandSurface","ice","iceSurface","snow","snowSurface","tree","treeSurface","mud","mudSurface","mouseDown","Pathfind","useState","Grid","setGrid","toggleBFS","setToggleBFS","startCords","setStartCords","rows","cols","endCords","setEndCords","wallCords","setWallCords","deleteWallCords","setDeleteWallCords","toggleDijkstra","setToggleDijkstra","sandCords","setSandCords","iceCords","setIceCords","snowCords","setSnowCords","treeCords","setTreeCords","mudCords","setMudCords","deleteSurface","setDeleteSurface","allDeleted","setAllDeleted","toggleAstar","setToggleAstar","path","setPath","sendData","setSendData","totalWeightDijkstra","setTotalWeightDijkstra","totalWeightAstar","setTotalWeightAstar","START_ROW","START_COL","END_ROW","END_COL","useEffect","initializeGrid","sendPath","console","log","axios","post","res","grid","j","Spot","BFSalg","DijkstraAlg","AstarAlg","drawingWalls","drawingSurfaces","forEach","el","weight","Fcost","find2D","arr","searchVal","output","totalWeightFun","alg","totalWeightArr","found","reduce","start","end","dict","curPos","result","reverse","pop","drawPath","queue","cord","neighbours","findNeighbours","mem","BFS","fillPath","showDijkstra","PQ","enqueue","dequeue","Dijkstra","totalWeight","showAstar","Gcost","Hcost","Astar","wallSpot","surfaceTypes","type","chosenSurface","surface","surfacearr","setSurfaceCords","undefined","classList","pos","split","onSuerface","name","gridwithNode","data","getData","document","getElementById","startcords","nativeEvent","srcElement","endcords","onMouseDown","cond","onMouseOver","onMouseUp","map","rowIndex","key","colIndex","onClick","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.4e4d71a9.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css';\n\nconst Node = ({ isStart, isEnd, searched, isPath, row, col, isWall, surfaceType }) => {\n\n    // let nodeObj = {\n    //     \"isStart\": isStart,\n    //     \"isEnd\": isEnd,\n    //     \"isPath\": isPath,\n    //     \"isWall\": isWall,\n    //     \"surfaceType\": surfaceType,\n    // }\n\n\n    // let nodeArr = [isStart, isEnd, isPath, isWall, surfaceType]\n\n\n    const selClass = () => {\n        if (isStart) {\n            return \"node_start\";\n        }\n        if (isEnd) {\n            return \"node_end\";\n        }\n        if (isPath) {\n            if (surfaceType === \"sand\") {\n                return \"node_path node_sand\";\n            }\n            if (surfaceType === \"ice\") {\n                return \"node_path node_ice\";\n            }\n            if (surfaceType === \"snow\") {\n                return \"node_path node_snow\";\n            }\n            if (surfaceType === \"tree\") {\n                return \"node_path node_tree\";\n            }\n            if (surfaceType === \"mud\") {\n                return \"node_path node_mud\";\n            }\n\n            return \"node_path\";\n        }\n        if (isWall) {\n            return \"node_wall\";\n        }\n        if (surfaceType === \"sand\") {\n            return \"node_sand\";\n        }\n        if (surfaceType === \"ice\") {\n            return \"node_ice\";\n        }\n        if (surfaceType === \"snow\") {\n            return \"node_snow\";\n        }\n        if (surfaceType === \"tree\") {\n            return \"node_tree\";\n        }\n        if (surfaceType === \"mud\") {\n            return \"node_mud\";\n        } else {\n            return \"\";\n        }\n    }\n\n    const classes = selClass();\n    const draggAble = isStart ? true : isEnd ? true : false;\n\n\n    const onDrop = (e) => {\n        e.preventDefault();\n        // let data = e.dataTransfer.getData(\"text\");\n    }\n\n\n    const onDragStart = (e) => {\n        e.dataTransfer.setData(\"text\", e.target.id);\n    }\n\n\n    const onDragOver = (e) => {\n        e.dataTransfer.setData(\"text\", e.target.id);\n    }\n\n\n    return (\n        <div\n            id={`node-${row}-${col}`}\n            onDrop={(e) => (onDrop(e))}\n            onDragOver={(e) => (onDragOver(e))}\n        >\n            <div\n                id={`${row}-${col}`}\n                className={`node ${classes}`}\n                draggable={draggAble}\n                onDragStart={(e) => {\n                    if (e.target.draggable === true) {\n                        onDragStart(e);\n                    } else {\n                        e.preventDefault();\n                    }\n                }}\n            />\n        </div>\n    )\n}\n\nexport default Node;","function equal(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length !== b.length) return false;\n\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n}\n\nconst findNeighbours = (grid, cord) => {\n    let neighbours = [];\n\n    //Nahoru\n    if (cord[0] + 1 < grid.length) {\n        neighbours.push([cord[0] + 1, cord[1]])\n    }\n\n    //Dolu\n    if (cord[0] - 1 >= 0) {\n        neighbours.push([cord[0] - 1, cord[1]])\n    }\n\n    //Doleva\n    if (cord[1] - 1 >= 0) {\n        neighbours.push([cord[0], cord[1] - 1])\n    }\n\n    //Doprava\n    if (cord[1] + 1 < grid[0].length) {\n        neighbours.push([cord[0], cord[1] + 1])\n    }\n\n    return neighbours;\n}\n\n\nexport const BFS = (grid, start, end) => {\n    let queue = []\n    start.searched = true\n    queue.push(start)\n    let dict = {};\n\n    while (queue.length > 0) {\n        let current = queue.shift();\n\n        if (current === end) {\n            console.log(\"Found\");\n            break;\n        } else {\n            let neighbours = findNeighbours(grid, [current.y, current.x])\n\n            neighbours.forEach(el => {\n                let mem = grid[el[0]][el[1]];\n                if (mem.searched === false && mem.isWall === false) {\n                    mem.searched = true;\n                    queue.push(mem);\n                    dict[[el[0], el[1]]] = [current.y, current.x];\n                };\n            });\n        }\n    };\n\n    return dict;\n};\n\nexport const drawPath = (dict, start, end) => {\n    let curPos = end;\n    const result = [];\n\n    while (!equal(curPos, start)) {\n        result.push(curPos);\n        curPos = dict[curPos];\n    }\n\n    result.push(start);\n    let path = result.reverse();\n    path.shift();\n    path.pop();\n\n    return path;\n}\n","function equal(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length !== b.length) return false;\n\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n\n\nclass QElement {\n    constructor(element, priority) {\n        this.element = element;\n        this.priority = priority;\n    }\n}\n\n\nclass PriorityQueue {\n    constructor() {\n        this.items = [];\n    }\n\n    enqueue(element, priority) {\n        let qElement = new QElement(element, priority);\n        let contain = false;\n\n        for (let i = 0; i < this.items.length; i++) {\n            if (this.items[i].priority > qElement.priority) {\n                this.items.splice(i, 0, qElement);\n                contain = true;\n                break;\n            }\n        }\n\n        if (!contain) {\n            this.items.push(qElement);\n        }\n    }\n\n    dequeue() {\n        if (this.isEmpty()) {\n            return \"Underflow\"\n        } else {\n            return this.items.shift()\n        }\n    }\n\n    isEmpty() {\n        return this.items.length === 0;\n    }\n}\n\n\nconst findNeighbours = (grid, cord) => {\n    let neighbours = [];\n\n    //Nahoru\n    if (cord[0] + 1 < grid.length) {\n        neighbours.push([cord[0] + 1, cord[1]])\n    }\n\n    //Dolu\n    if (cord[0] - 1 >= 0) {\n        neighbours.push([cord[0] - 1, cord[1]])\n    }\n\n    //Doleva\n    if (cord[1] - 1 >= 0) {\n        neighbours.push([cord[0], cord[1] - 1])\n    }\n\n    //Doprava\n    if (cord[1] + 1 < grid[0].length) {\n        neighbours.push([cord[0], cord[1] + 1])\n    }\n\n    return neighbours;\n}\n\n\nexport const Dijkstra = (grid, start, end) => {\n    const PQ = new PriorityQueue();\n    let dict = {};\n    start.weight = 0;\n    start.searched = true;\n    PQ.enqueue(start, start.weight);\n\n    while (PQ.items.length > 0) {\n        let curr = PQ.dequeue();\n        let current = curr.element;\n\n        if (current === end) {\n            console.log(\"Found\");\n            break;\n        } else {\n            let neighbours = findNeighbours(grid, [current.y, current.x]);\n\n            neighbours.forEach(el => {\n                let mem = grid[el[0]][el[1]];\n\n                if (mem.searched === false && mem.isWall === false) {\n                    mem.searched = true;\n                    mem.weight = current.weight + mem.weight;\n                    PQ.enqueue(mem, mem.weight);\n                    dict[[el[0], el[1]]] = [current.y, current.x];\n                }\n            })\n        }\n    }\n\n    return dict;\n}\n\nexport const showDijkstra = (dict, start, end) => {\n    let curPos = end;\n    const result = [];\n\n    // console.log(dict)\n\n    while (!equal(curPos, start)) {\n        result.push(curPos);\n        curPos = dict[curPos];\n    }\n\n    result.push(start);\n    let path = result.reverse();\n    path.shift();\n    path.pop();\n\n    return path;\n}\n\n\n","function equal(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length !== b.length) return false;\n\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n\n\nclass QElement {\n    constructor(element, priority) {\n        this.element = element;\n        this.priority = priority;\n    }\n}\n\n\nclass PriorityQueue {\n    constructor() {\n        this.items = [];\n    }\n\n    enqueue(element, priority) {\n        let qElement = new QElement(element, priority);\n        let contain = false;\n\n        for (let i = 0; i < this.items.length; i++) {\n            if (this.items[i].priority > qElement.priority) {\n                this.items.splice(i, 0, qElement);\n                contain = true;\n                break;\n            }\n        }\n\n        if (!contain) {\n            this.items.push(qElement);\n        }\n    }\n\n    dequeue() {\n        if (this.isEmpty()) {\n            return \"Nejde\"\n        } else {\n            return this.items.shift()\n        }\n    }\n\n    isEmpty() {\n        return this.items.length === 0;\n    }\n}\n\n\nconst findNeighbours = (grid, cord) => {\n    let neighbours = [];\n\n    //Nahoru\n    if (cord[0] + 1 < grid.length) {\n        neighbours.push([cord[0] + 1, cord[1]])\n    }\n\n    //Dolu\n    if (cord[0] - 1 >= 0) {\n        neighbours.push([cord[0] - 1, cord[1]])\n    }\n\n    //Doleva\n    if (cord[1] - 1 >= 0) {\n        neighbours.push([cord[0], cord[1] - 1])\n    }\n\n    //Doprava\n    if (cord[1] + 1 < grid[0].length) {\n        neighbours.push([cord[0], cord[1] + 1])\n    }\n\n\n    return neighbours;\n}\n\n\nconst heuristic = (goal, current) => {\n    return (Math.abs(goal.y - current.y) + Math.abs(goal.x - current.x)) * 10\n}\n\n\nexport const Astar = (grid, start, end) => {\n    const PQ = new PriorityQueue()\n    let dict = {};\n    start.searched = true;\n    start.Gcost = 0;\n    start.Hcost = heuristic(end, start);\n    start.Fcost = start.Gcost + start.Hcost\n    PQ.enqueue(start, start.Fcost);\n\n    while (PQ.items.length > 0) {\n        let curr = PQ.dequeue();\n        let current = curr.element;\n\n        if (current.y === end.y && current.x === end.x) {\n            console.log(\"Found\");\n            break;\n        } else {\n            let neighbours = findNeighbours(grid, [current.y, current.x]);\n\n            neighbours.forEach(el => {\n                let mem = grid[el[0]][el[1]];\n\n                if (mem.searched === false && mem.isWall === false) {\n                    mem.searched = true;\n                    mem.Gcost = current.Gcost + 10;\n                    mem.Hcost = heuristic(end, current);\n                    mem.Fcost = mem.Gcost + mem.Hcost + mem.Fcost;\n                    PQ.enqueue(mem, mem.Fcost);\n                    dict[[el[0], el[1]]] = [current.y, current.x]\n                }\n            })\n        }\n    }\n\n    return dict;\n}\n\nexport const showAstar = (dict, start, end) => {\n    let curPos = end;\n    const result = [];\n\n    while (!equal(curPos, start)) {\n        result.push(curPos);\n        curPos = dict[curPos];\n    }\n\n    result.push(start);\n    result.reverse();\n    result.shift();\n    result.pop();\n\n    return result;\n}\n","import React, { useState, useEffect } from 'react'\nimport Node from './Node.jsx';\nimport './Pathfind.css';\nimport { BFS, drawPath } from '../Algorithms/Bfs';\nimport { Dijkstra, showDijkstra } from '../Algorithms/Dijkstra';\nimport { Astar, showAstar } from '../Algorithms/Astar';\nimport axios from 'axios';\nimport ClearIcon from '@material-ui/icons/Clear';\nimport DoneIcon from '@material-ui/icons/Done';\n\n\n//GLOBAL\nconst cols = 27;\nconst rows = 20;\nlet wall = [];\nlet sand = 0;\nlet sandSurface = [];\nlet ice = 0;\nlet iceSurface = [];\nlet snow = 0;\nlet snowSurface = [];\nlet tree = 0;\nlet treeSurface = [];\nlet mud = 0;\nlet mudSurface = [];\nlet mouseDown = 0;\n\n\nconst Pathfind = () => {\n    const [Grid, setGrid] = useState([]);\n    const [toggleBFS, setToggleBFS] = useState(0);\n    const [startCords, setStartCords] = useState([0, 0]);\n    const [endCords, setEndCords] = useState([rows - 1, cols - 1]);\n    const [wallCords, setWallCords] = useState([]);\n    const [deleteWallCords, setDeleteWallCords] = useState([]);\n    const [toggleDijkstra, setToggleDijkstra] = useState(0);\n    const [sandCords, setSandCords] = useState([]);\n    const [iceCords, setIceCords] = useState([]);\n    const [snowCords, setSnowCords] = useState([]);\n    const [treeCords, setTreeCords] = useState([]);\n    const [mudCords, setMudCords] = useState([]);\n    const [deleteSurface, setDeleteSurface] = useState([]);\n    const [allDeleted, setAllDeleted] = useState(0);\n    const [toggleAstar, setToggleAstar] = useState(0);\n    const [path, setPath] = useState(null);\n    const [sendData, setSendData] = useState(0);\n    const [totalWeightDijkstra, setTotalWeightDijkstra] = useState(0);\n    const [totalWeightAstar, setTotalWeightAstar] = useState(0);\n\n\n\n    const START_ROW = startCords[0];\n    const START_COL = startCords[1];\n    const END_ROW = endCords[0];\n    const END_COL = endCords[1];\n\n\n    useEffect(() => {\n        initializeGrid();\n    }, [toggleBFS, toggleDijkstra, toggleAstar, startCords, endCords, wallCords,\n        deleteWallCords, sandCords, iceCords, snowCords, treeCords, mudCords, deleteSurface, allDeleted]);\n\n    useEffect(() => {\n        sendPath();\n    }, [sendData]);\n\n    const sendPath = async() => {\n        console.log(\"funguje\");\n        let res = await axios.post('http://localhost:5000/sendPath', {\n            \"path\": path \n        })\n\n        console.log(res);\n\n        setPath(null)\n    }\n   \n\n    //Inicializace gridu\n    const initializeGrid = () => {\n        const grid = [];\n\n        //Naplneni gridu(grafu)\n        for (let i = 0; i < rows; i++) {\n            grid[i] = [];\n            for (let j = 0; j < cols; j++) {\n                grid[i][j] = new Spot(i, j);\n            }\n        }\n\n        //BFS algoritmus\n        if (toggleBFS === 1) {\n            BFSalg(grid);\n        }\n        //Dijkstruv algoritmus\n        if (toggleDijkstra === 1) {\n            DijkstraAlg(grid);\n        }\n        //Astart algoritmus\n        if (toggleAstar === 1) {\n            AstarAlg(grid);\n        } else {\n            setGrid(grid);\n            drawingWalls(grid);\n            drawingSurfaces(grid);\n        }\n    };\n\n\n    //Funkce na kresleni sten\n    const drawingWalls = (grid) => {\n        if (typeof wallCords.y === \"string\") {\n            wall.push(wallCords);\n\n            wall.forEach((el) => {\n                if (grid[el.y][el.x].isWall === false && el.isWall === true) {\n                    grid[el.y][el.x].isWall = true;\n                }\n\n                if (grid[el.y][el.x].isWall === true && el.isWall === false) {\n                    grid[el.y][el.x].isWall = false;\n                }\n            })\n        }\n    }\n\n\n    const drawingSurfaces = (grid) => {\n        if (typeof sandCords.y === \"string\") {\n            sandSurface.push(sandCords);\n\n            sandSurface.forEach((el) => {\n                if (grid[el.y][el.x].surfaceType === \"none\" && el.surfaceType !== \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                    grid[el.y][el.x].weight = el.weight;\n                    grid[el.y][el.x].Fcost = el.Fcost;\n                }\n\n                if (grid[el.y][el.x].surfaceType !== \"none\" && el.surfaceType === \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                }\n            })\n        }\n\n\n        if (typeof iceCords.y === \"string\") {\n            iceSurface.push(iceCords);\n\n            iceSurface.forEach((el) => {\n                if (grid[el.y][el.x].surfaceType === \"none\" && el.surfaceType !== \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                    grid[el.y][el.x].weight = el.weight;\n                    grid[el.y][el.x].Fcost = el.Fcost;\n                }\n\n                if (grid[el.y][el.x].surfaceType !== \"none\" && el.surfaceType === \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                }\n            })\n        }\n\n\n        if (typeof snowCords.y === \"string\") {\n            snowSurface.push(snowCords);\n\n            snowSurface.forEach((el) => {\n                if (grid[el.y][el.x].surfaceType === \"none\" && el.surfaceType !== \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                    grid[el.y][el.x].weight = el.weight;\n                    grid[el.y][el.x].Fcost = el.Fcost;\n                }\n\n                if (grid[el.y][el.x].surfaceType !== \"none\" && el.surfaceType === \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                }\n            })\n        }\n\n\n        if (typeof treeCords.y === \"string\") {\n            treeSurface.push(treeCords);\n\n            treeSurface.forEach((el) => {\n                if (grid[el.y][el.x].surfaceType === \"none\" && el.surfaceType !== \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                    grid[el.y][el.x].weight = el.weight;\n                    grid[el.y][el.x].Fcost = el.Fcost;\n                }\n\n                if (grid[el.y][el.x].surfaceType !== \"none\" && el.surfaceType === \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                }\n            })\n        }\n\n\n        if (typeof mudCords.y === \"string\") {\n            mudSurface.push(mudCords);\n\n            mudSurface.forEach((el) => {\n                if (grid[el.y][el.x].surfaceType === \"none\" && el.surfaceType !== \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                    grid[el.y][el.x].weight = el.weight;\n                    grid[el.y][el.x].Fcost = el.Fcost;\n                }\n\n                if (grid[el.y][el.x].surfaceType !== \"none\" && el.surfaceType === \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                }\n            })\n        }\n    }\n\n\n    const find2D = (arr, searchVal) => {\n        let output;\n    \n        arr.forEach((e) => {\n            e.forEach((e) => {\n                // console.log(e)\n                if(e.y === searchVal[0] && e.x === searchVal[1] ) {\n                    // console.log(e)\n                    output = e;\n                }\n            })\n        })\n    \n        return output;\n    }\n\n\n    const totalWeightFun = (grid, path, alg) => {\n        let totalWeightArr = [];\n\n        if(alg === \"Dijkstra\") {\n            path.forEach(e => {\n                // console.log(e)\n                const found = find2D(grid, [e[0], e[1]]);\n                totalWeightArr.push(found.weight);\n            })\n        }\n        \n        if(alg === \"Astar\") {\n            path.forEach(e => {\n                // console.log(e)\n                const found = find2D(grid, [e[0], e[1]]);\n                totalWeightArr.push(found.Fcost);\n            })\n        }\n        \n        let totalWeight = totalWeightArr.reduce((a, b) => a + b, 0);\n        return totalWeight;    \n    }\n\n\n    //Implementace BFS\n    const BFSalg = (grid) => {\n        drawingWalls(grid);\n\n        let start = grid[START_ROW][START_COL];\n        let end = grid[END_ROW][END_COL];\n\n        setGrid(grid);\n\n        const dict = BFS(grid, start, end);\n        const path = drawPath(dict, [start.y, start.x], [end.y, end.x]);\n        setPath(path);\n        console.log(path)\n\n        fillPath(grid, path);\n    }\n\n\n    //Implementace Dijkstry\n    const DijkstraAlg = (grid) => {\n        drawingWalls(grid);\n        drawingSurfaces(grid);\n\n        let start = grid[START_ROW][START_COL];\n        let end = grid[END_ROW][END_COL];\n\n        setGrid(grid);\n\n        const dict = Dijkstra(grid, start, end);\n        const path = showDijkstra(dict, [start.y, start.x], [end.y, end.x]);\n        setPath(path);\n\n        fillPath(grid, path);\n\n        const totalWeight = totalWeightFun(grid, path, \"Dijkstra\");\n        setTotalWeightDijkstra(totalWeight / 100);\n    }\n\n    const AstarAlg = (grid) => {\n        drawingWalls(grid);\n        drawingSurfaces(grid);\n\n        let start = grid[START_ROW][START_COL];\n        let end = grid[END_ROW][END_COL];\n\n        setGrid(grid);\n\n        const dict = Astar(grid, start, end);\n        const path = showAstar(dict, [start.y, start.x], [end.y, end.x])\n        setPath(path);\n\n        fillPath(grid, path);\n\n        const totalWeight = totalWeightFun(grid, path, \"Astar\");\n        console.log(totalWeight);\n        setTotalWeightAstar(totalWeight / 100);\n    }\n\n\n    //Vytvoreni objektu pro kresleni sten\n    function wallSpot(y, x, isWall) {\n        this.y = y;\n        this.x = x;\n        this.isWall = isWall;\n    }\n\n\n    //Objekt porvrchu\n    function surfaceTypes(y, x, type, weight, Fcost) {\n        this.y = y;\n        this.x = x;\n        this.surfaceType = type;\n        this.weight = weight;\n        this.Fcost = Fcost;\n    }\n\n\n    // Vytvoreni objektu pro jednotlive spoty v gridu(grafu)\n    function Spot(y, x) {\n        this.y = y;\n        this.x = x;\n        this.isStart = this.y === START_ROW && this.x === START_COL;\n        this.isEnd = this.y === END_ROW && this.x === END_COL;\n        this.searched = false;\n        this.isPath = false;\n        this.isWall = false;\n        this.surfaceType = \"none\";\n        this.weight = 1;\n        this.Gcost = 0;\n        this.Hcost = 0;\n        this.Fcost = this.Gcost + this.Hcost;\n    };\n\n\n    //Nasteveni promene isPath v kazdem spotu ktery je soucasti cesty na true\n    const fillPath = (grid, path) => {\n        for (let i = 0; i < path.length; i++) {\n            grid[path[i][0]][path[i][1]].isPath = true;\n        }\n    }\n\n\n    const onDrop = (e) => {\n        e.preventDefault();\n        let data = e.dataTransfer.getData(\"text\");\n        const el = document.getElementById(data);\n\n        if (el.className === \"node node_start\") {\n            let scords = e.nativeEvent.srcElement.id;\n            let startcords = scords.split(\"-\");\n            setStartCords(startcords);\n        } else {\n            let ecords = e.nativeEvent.srcElement.id;\n            let endcords = ecords.split(\"-\");\n            setEndCords(endcords);\n        }\n\n        e.nativeEvent.target.draggable = el.draggable\n        e.nativeEvent.target.className = el.className\n\n        el.draggable = false;\n        el.className = \"node\";\n    }\n\n\n    const onDragOver = (e) => {\n        e.preventDefault();\n    }\n\n\n    const chosenSurface = (surface, surfacearr, weight, e, setSurfaceCords, Fcost) => {\n        if (e.target.classList[1] === undefined) {\n            let memPos = e.target.id;\n            let pos = memPos.split(\"-\");\n            setSurfaceCords(new surfaceTypes(pos[0], pos[1], surface, weight, Fcost));\n        }\n        if (e.target.classList[1] === \"node_\" + surface) {\n            let memPos = e.target.id;\n            let pos = memPos.split(\"-\");\n            setDeleteSurface(pos);\n\n            surfacearr.forEach((el) => {\n                if (el.y === pos[0] && el.x === pos[1]) {\n                    el.surfaceType = \"none\";\n                }\n            })\n        }\n    }\n\n\n    const onMouseDown = (e) => {\n        const cond = sand + ice + snow + tree + mud;\n        mouseDown = 1\n\n        if (cond > 0) {\n            switch (cond) {\n                case 1:\n                    chosenSurface(\"sand\", sandSurface, 5, e, setSandCords, 5);\n                    break;\n                case 2:\n                    chosenSurface(\"ice\", iceSurface, 15, e, setIceCords, 15);\n                    break;\n                case 3:\n                    chosenSurface(\"snow\", snowSurface, 10, e, setSnowCords, 10)\n                    break;\n                case 4:\n                    chosenSurface(\"tree\", treeSurface, 3, e, setTreeCords, 3);\n                    break;\n                case 5:\n                    chosenSurface(\"mud\", mudSurface, 7, e, setMudCords, 7);\n                    break;\n                default:\n                    console.log(\"Nothing selected\");\n            }\n        } else {\n            if (e.target.classList[1] === undefined || e.target.classList[1] === \"node_\") {\n                let memPos = e.target.id;\n                let pos = memPos.split(\"-\");\n                setWallCords(new wallSpot(pos[0], pos[1], true));\n            }\n\n            if (e.target.classList[1] === \"node_wall\") {\n                let memPos = e.target.id;\n                let pos = memPos.split(\"-\");\n                setDeleteWallCords(pos);\n\n                wall.forEach((el) => {\n                    if (el.y === pos[0] && el.x === pos[1]) {\n                        el.isWall = false;\n                    }\n                })\n            }\n        }\n    }\n\n\n    const onSuerface = (e) => {\n        switch (e.target.name) {\n            case \"Sand\":\n                if(sand === 0) {\n                    sand = 1;\n                    e.target.className = \"usedSand\";\n                } else {\n                    sand = 0;\n                    e.target.className = \"sand\";\n                }       \n                break;\n            case \"Ice\":\n                if(ice === 0) {\n                    ice = 2;\n                    e.target.className = \"usedIce\";\n                } else {\n                    ice = 0;\n                    e.target.className = \"ice\";\n                }       \n                break;\n            case \"Snow\":\n                if(snow === 0) {\n                    snow = 3;\n                    e.target.className = \"usedSnow\";\n                } else {\n                    snow = 0;\n                    e.target.className = \"snow\";\n                }       \n                break;\n            case \"Tree\":\n                if(tree === 0) {\n                    tree = 4;\n                    e.target.className = \"usedTree\";\n                } else {\n                    tree = 0;\n                    e.target.className = \"tree\";\n                }       \n                break;\n            case \"Mud\":\n                if(mud === 0) {\n                    mud = 5;\n                    e.target.className = \"usedMud\";\n                } else {\n                    mud = 0;\n                    e.target.className = \"mud\";\n                }       \n                break;\n            default:\n                console.log(\"Nothing selected\");\n        }\n    }\n\n\n    const onMouseOver = (e) => {\n        const cond = sand + ice + snow + tree + mud;\n\n        if (mouseDown === 1) {\n            if (cond > 0) {\n                switch (cond) {\n                    case 1:\n                        chosenSurface(\"sand\", sandSurface, 5, e, setSandCords);\n                        break;\n                    case 2:\n                        chosenSurface(\"ice\", iceSurface, 15, e, setIceCords);\n                        break;\n                    case 3:\n                        chosenSurface(\"snow\", snowSurface, 10, e, setSnowCords);\n                        break;\n                    case 4:\n                        chosenSurface(\"tree\", treeSurface, 3, e, setTreeCords);\n                        break;\n                    case 5:\n                        chosenSurface(\"mud\", mudSurface, 7, e, setMudCords);\n                        break;\n                    default:\n                        console.log(\"Nothing selected\");\n                }\n            } else {\n                if (e.target.classList[1] === undefined || e.target.classList[1] === \"node_path\" || e.target.classList[1] === \"node_sand\"\n                    || e.target.classList[1] === \"node_ice\" || e.target.classList[1] === \"node_snow\" || e.target.classList[1] === \"node_tree\"\n                    || e.target.classList[1] === \"node_mud\") {\n                    let memPos = e.target.id;\n                    let pos = memPos.split(\"-\");\n                    setWallCords(new wallSpot(pos[0], pos[1], true));\n                }\n\n                if (e.target.classList[1] === \"node_wall\") {\n                    let memPos = e.target.id;\n                    let pos = memPos.split(\"-\");\n                    setDeleteWallCords(pos);\n\n                    wall.forEach((el) => {\n                        if (el.y === pos[0] && el.x === pos[1]) {\n                            el.isWall = false;\n                        }\n                    })\n                }\n            }\n        }\n    }\n\n\n    const onMouseUp = (e) => {\n        if (mouseDown === 1) {\n            mouseDown = 0\n        } else {\n            e.preventDefault();\n        }\n    }\n\n\n    const deleteAll = () => {\n        wall.forEach((el) => {\n            el.isWall = false;\n        })\n\n        sandSurface.forEach((el) => {\n            el.surfaceType = \"none\"\n        })\n\n\n        iceSurface.forEach((el) => {\n            el.surfaceType = \"none\"\n        })\n\n\n        snowSurface.forEach((el) => {\n            el.surfaceType = \"none\"\n        })\n\n\n        treeSurface.forEach((el) => {\n            el.surfaceType = \"none\"\n        })\n\n\n        mudSurface.forEach((el) => {\n            el.surfaceType = \"none\"\n        })\n\n        if (allDeleted === 0) {\n            setAllDeleted(1)\n        } else {\n            setAllDeleted(0)\n        }\n    }\n\n\n    const onSendData = () => {\n        if(sendData === 0) {\n            setSendData(1)\n        } else {\n            setSendData(0);\n        }\n    }\n\n\n    // Funkce na vykresleni gridu\n    const gridwithNode = (\n        <div className=\"Grid\" onDrop={(e) => (onDrop(e))} onDragOver={(e) => (onDragOver(e))}\n            onMouseDown={(e) => (onMouseDown(e))}\n            onMouseOver={(e) => (onMouseOver(e))}\n            onMouseUp={(e) => (onMouseUp(e))}\n        >\n            {\n                Grid.map((row, rowIndex) => {\n                    return (\n                        <div key={rowIndex} className='rowWrapper'>\n                            {row.map((col, colIndex) => {\n                                const { isStart, isEnd, searched, isPath, isWall, surfaceType } = col;\n                                return (\n                                    <Node key={colIndex}\n                                    isPath={isPath}\n                                    isWall={isWall}\n                                    isStart={isStart}\n                                    isEnd={isEnd}\n                                    searched={searched}\n                                    row={rowIndex}\n                                    col={colIndex}\n                                    surfaceType={surfaceType}\n                                    />\n                                    )\n                                })}\n                        </div>\n                    )\n                })\n            }\n        </div >\n    )\n    \n    \n    return (\n        <div className='Wrapper'>\n            <h1>Nejkratší cesta přes 2D pole</h1>\n            {/* Vykresleni gridu */}\n            {gridwithNode}\n            <div className=\"algButtons\">\n                <div className=\"BFSbuttons\">\n                    <button className=\"bfsOn\" onClick={() => setToggleBFS(1)}>Zapni BFS</button>\n                    <button className=\"bfsOff\" onClick={() => {if(toggleBFS === 1) {setToggleBFS(0)}}}>Vypni BFS</button>\n                </div>\n                <div className=\"dijkstraButtons\">\n                    <button className=\"dijkstraOn\" onClick={() => setToggleDijkstra(1)}>Zapni Dijkstru</button>\n                    <button className=\"dijkstraOff\" onClick={() => {if(toggleDijkstra === 1) {setToggleDijkstra(0)}}}>Vypni Dijkstru</button>\n                </div>\n                <div className=\"astarButtons\">\n                    <button className=\"astarOn\" onClick={() => setToggleAstar(1)}>Zapni Astar</button>\n                    <button className=\"astarOff\" onClick={() => {if(toggleAstar === 1) {setToggleAstar(0)}}}>Vypni Astar</button>\n                </div>\n            </div>\n            <div className=\"utilityButtons\">\n                <div className=\"surfaceButtons\">\n                    <button className=\"sand\" onClick={(e) => onSuerface(e)} name=\"Sand\">Písek</button>\n                    <button className=\"ice\" onClick={(e) => onSuerface(e)} name=\"Ice\">Led</button>\n                    <button className=\"snow\" onClick={(e) => onSuerface(e)} name=\"Snow\">Sníh</button>\n                    <button className=\"tree\" onClick={(e) => onSuerface(e)} name=\"Tree\">Stromy</button>\n                    <button className=\"mud\" onClick={(e) => onSuerface(e)} name=\"Mud\">Bahno</button>\n                </div>\n                <div className=\"delButtons\">\n                    <button className=\"deleteAll\" onClick={() => { deleteAll() }}>Delete ALL <ClearIcon className=\"clearIcon\"/></button>\n                    <button className=\"sendData\" onClick={() => { onSendData() }}>Send Data <DoneIcon className=\"doneIcon\"/></button>\n                </div>\n            </div>\n            <div className=\"outputs\">\n                <div className=\"dijkstra\">{ toggleDijkstra === 1 ? totalWeightDijkstra : 0 }</div>\n                <div className=\"astar\">{ toggleAstar === 1 ? totalWeightAstar : 0 }</div>\n            </div>\n        </div>\n    )\n}\n\nexport default Pathfind\n","import React from 'react';\nimport './App.css';\nimport Pathfinding from './components/Pathfind.jsx'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Pathfinding />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App.jsx';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}