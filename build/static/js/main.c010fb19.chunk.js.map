{"version":3,"sources":["components/Node.jsx","Algorithms/Bfs.js","Algorithms/Dijkstra.js","Algorithms/Astar.js","components/Pathfind.jsx","App.jsx","index.js"],"names":["Node","isStart","isEnd","isPath","searched","row","col","isWall","surfaceType","classes","draggAble","id","onDrop","e","preventDefault","onDragOver","dataTransfer","setData","target","className","draggable","onDragStart","equal","a","b","length","i","QElement","element","priority","this","PriorityQueue","items","qElement","contain","splice","push","isEmpty","shift","heuristic","goal","current","Math","abs","y","x","wall","sand","sandSurface","ice","iceSurface","snow","snowSurface","tree","treeSurface","mud","mudSurface","mouseDown","Pathfind","useState","Grid","setGrid","toggleBFS","setToggleBFS","startCords","setStartCords","rows","cols","endCords","setEndCords","wallCords","setWallCords","deleteWallCords","setDeleteWallCords","toggleDijkstra","setToggleDijkstra","sandCords","setSandCords","iceCords","setIceCords","snowCords","setSnowCords","treeCords","setTreeCords","mudCords","setMudCords","deleteSurface","setDeleteSurface","allDeleted","setAllDeleted","toggleAstar","setToggleAstar","path","setPath","sendData","setSendData","START_ROW","START_COL","END_ROW","END_COL","useEffect","initializeGrid","sendPath","console","log","axios","post","res","grid","j","Spot","BFSalg","DijkstraAlg","AstarAlg","drawingWalls","drawingSurfaces","forEach","el","weight","Fcost","findV2","arr","searchVal","output","totalWeightFun","alg","totalWeightArr","found","start","end","dict","curPos","result","reverse","pop","drawPath","queue","cord","neighbours","findNeighbours","mem","BFS","fillPath","showDijkstra","PQ","enqueue","dequeue","Dijkstra","showAstar","Gcost","Hcost","nb","Astar","wallSpot","surfaceTypes","type","chosenSurface","surface","surfacearr","setSurfaceCords","undefined","classList","pos","split","onSuerface","name","gridwithNode","data","getData","document","getElementById","startcords","nativeEvent","srcElement","endcords","onMouseDown","cond","onMouseOver","onMouseUp","map","rowIndex","key","colIndex","onClick","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.c010fb19.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css';\n\nconst Node = ({ isStart, isEnd, searched, isPath, row, col, isWall, surfaceType }) => {\n\n    // let nodeObj = {\n    //     \"isStart\": isStart,\n    //     \"isEnd\": isEnd,\n    //     \"isPath\": isPath,\n    //     \"isWall\": isWall,\n    //     \"surfaceType\": surfaceType,\n    // }\n\n\n    // let nodeArr = [isStart, isEnd, isPath, isWall, surfaceType]\n\n\n    const selClass = () => {\n        if (isStart) {\n            return \"node_start\";\n        }\n        if (isEnd) {\n            return \"node_end\";\n        }\n        if (isPath) {\n            if (surfaceType === \"sand\") {\n                return \"node_path node_sand\";\n            }\n            if (surfaceType === \"ice\") {\n                return \"node_path node_ice\";\n            }\n            if (surfaceType === \"snow\") {\n                return \"node_path node_snow\";\n            }\n            if (surfaceType === \"tree\") {\n                return \"node_path node_tree\";\n            }\n            if (surfaceType === \"mud\") {\n                return \"node_path node_mud\";\n            }\n\n            return \"node_path\";\n        }\n        if (isWall) {\n            return \"node_wall\";\n        }\n        if (surfaceType === \"sand\") {\n            return \"node_sand\";\n        }\n        if (surfaceType === \"ice\") {\n            return \"node_ice\";\n        }\n        if (surfaceType === \"snow\") {\n            return \"node_snow\";\n        }\n        if (surfaceType === \"tree\") {\n            return \"node_tree\";\n        }\n        if (surfaceType === \"mud\") {\n            return \"node_mud\";\n        } else {\n            return \"\";\n        }\n    }\n\n    const classes = selClass();\n    const draggAble = isStart ? true : isEnd ? true : false;\n\n\n    const onDrop = (e) => {\n        e.preventDefault();\n        // let data = e.dataTransfer.getData(\"text\");\n    }\n\n\n    const onDragStart = (e) => {\n        e.dataTransfer.setData(\"text\", e.target.id);\n    }\n\n\n    const onDragOver = (e) => {\n        e.dataTransfer.setData(\"text\", e.target.id);\n    }\n\n\n    return (\n        <div\n            id={`node-${row}-${col}`}\n            onDrop={(e) => (onDrop(e))}\n            onDragOver={(e) => (onDragOver(e))}\n        >\n            <div\n                id={`${row}-${col}`}\n                className={`node ${classes}`}\n                draggable={draggAble}\n                onDragStart={(e) => {\n                    if (e.target.draggable === true) {\n                        onDragStart(e);\n                    } else {\n                        e.preventDefault();\n                    }\n                }}\n            />\n        </div>\n    )\n}\n\nexport default Node;","function equal(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length !== b.length) return false;\n\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n}\n\nconst findNeighbours = (grid, cord) => {\n    let neighbours = [];\n\n    //Nahoru\n    if (cord[0] + 1 < grid.length) {\n        neighbours.push([cord[0] + 1, cord[1]])\n    }\n\n    //Dolu\n    if (cord[0] - 1 >= 0) {\n        neighbours.push([cord[0] - 1, cord[1]])\n    }\n\n    //Doleva\n    if (cord[1] - 1 >= 0) {\n        neighbours.push([cord[0], cord[1] - 1])\n    }\n\n    //Doprava\n    if (cord[1] + 1 < grid[0].length) {\n        neighbours.push([cord[0], cord[1] + 1])\n    }\n\n    return neighbours;\n}\n\n\nexport const BFS = (grid, start, end) => {\n    let queue = []\n    start.searched = true\n    queue.push(start)\n    let dict = {};\n\n    while (queue.length > 0) {\n        let current = queue.shift();\n\n        if (current === end) {\n            console.log(\"Found\");\n            break;\n        } else {\n            let neighbours = findNeighbours(grid, [current.y, current.x])\n\n            neighbours.forEach(el => {\n                let mem = grid[el[0]][el[1]];\n                if (mem.searched === false && mem.isWall === false) {\n                    mem.searched = true;\n                    queue.push(mem);\n                    dict[[el[0], el[1]]] = [current.y, current.x];\n                };\n            });\n        }\n    };\n\n    return dict;\n};\n\nexport const drawPath = (dict, start, end) => {\n    let curPos = end;\n    const result = [];\n\n    while (!equal(curPos, start)) {\n        result.push(curPos);\n        curPos = dict[curPos];\n    }\n\n    result.push(start);\n    let path = result.reverse();\n    path.shift();\n    path.pop();\n\n    return path;\n}\n","function equal(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length !== b.length) return false;\n\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n\n\nclass QElement {\n    constructor(element, priority) {\n        this.element = element;\n        this.priority = priority;\n    }\n}\n\n\nclass PriorityQueue {\n    constructor() {\n        this.items = [];\n    }\n\n    enqueue(element, priority) {\n        let qElement = new QElement(element, priority);\n        let contain = false;\n\n        for (let i = 0; i < this.items.length; i++) {\n            if (this.items[i].priority > qElement.priority) {\n                this.items.splice(i, 0, qElement);\n                contain = true;\n                break;\n            }\n        }\n\n        if (!contain) {\n            this.items.push(qElement);\n        }\n    }\n\n    dequeue() {\n        if (this.isEmpty()) {\n            return \"Underflow\"\n        } else {\n            return this.items.shift()\n        }\n    }\n\n    isEmpty() {\n        return this.items.length === 0;\n    }\n}\n\n\nconst findNeighbours = (grid, cord) => {\n    let neighbours = [];\n\n    //Nahoru\n    if (cord[0] + 1 < grid.length) {\n        neighbours.push([cord[0] + 1, cord[1]])\n    }\n\n    //Dolu\n    if (cord[0] - 1 >= 0) {\n        neighbours.push([cord[0] - 1, cord[1]])\n    }\n\n    //Doleva\n    if (cord[1] - 1 >= 0) {\n        neighbours.push([cord[0], cord[1] - 1])\n    }\n\n    //Doprava\n    if (cord[1] + 1 < grid[0].length) {\n        neighbours.push([cord[0], cord[1] + 1])\n    }\n\n    return neighbours;\n}\n\n\nexport const Dijkstra = (grid, start, end) => {\n    const PQ = new PriorityQueue();\n    let dict = {};\n    start.weight = 0;\n    start.searched = true;\n    PQ.enqueue(start, start.weight);\n\n    while (PQ.items.length > 0) {\n        let curr = PQ.dequeue();\n        let current = curr.element;\n\n        if (current === end) {\n            console.log(\"Found\");\n            break;\n        } else {\n            let neighbours = findNeighbours(grid, [current.y, current.x]);\n\n            neighbours.forEach(el => {\n                let mem = grid[el[0]][el[1]];\n\n                if (mem.searched === false && mem.isWall === false) {\n                    mem.searched = true;\n                    mem.weight = current.weight + mem.weight;\n                    PQ.enqueue(mem, mem.weight);\n                    dict[[el[0], el[1]]] = [current.y, current.x];\n                }\n            })\n        }\n    }\n\n    return dict;\n}\n\nexport const showDijkstra = (dict, start, end) => {\n    let curPos = end;\n    const result = [];\n\n    // console.log(dict)\n\n    while (!equal(curPos, start)) {\n        result.push(curPos);\n        curPos = dict[curPos];\n    }\n\n    result.push(start);\n    let path = result.reverse();\n    path.shift();\n    path.pop();\n\n    return path;\n}\n\n\n","function equal(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length !== b.length) return false;\n\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n\n\nclass QElement {\n    constructor(element, priority) {\n        this.element = element;\n        this.priority = priority;\n    }\n}\n\n\nclass PriorityQueue {\n    constructor() {\n        this.items = [];\n    }\n\n    enqueue(element, priority) {\n        let qElement = new QElement(element, priority);\n        let contain = false;\n\n        for (let i = 0; i < this.items.length; i++) {\n            if (this.items[i].priority > qElement.priority) {\n                this.items.splice(i, 0, qElement);\n                contain = true;\n                break;\n            }\n        }\n\n        if (!contain) {\n            this.items.push(qElement);\n        }\n    }\n\n    dequeue() {\n        if (this.isEmpty()) {\n            return \"Nejde\"\n        } else {\n            return this.items.shift()\n        }\n    }\n\n    isEmpty() {\n        return this.items.length === 0;\n    }\n}\n\n\nconst findNeighbours = (grid, cord) => {\n    let neighbours = [];\n\n    //Nahoru\n    if (cord[0] + 1 < grid.length) {\n        neighbours.push([cord[0] + 1, cord[1]])\n    }\n\n    //Dolu\n    if (cord[0] - 1 >= 0) {\n        neighbours.push([cord[0] - 1, cord[1]])\n    }\n\n    //Doleva\n    if (cord[1] - 1 >= 0) {\n        neighbours.push([cord[0], cord[1] - 1])\n    }\n\n    //Doprava\n    if (cord[1] + 1 < grid[0].length) {\n        neighbours.push([cord[0], cord[1] + 1])\n    }\n\n\n    return neighbours;\n}\n\n\nconst heuristic = (goal, current) => {\n    return (Math.abs(goal.y - current.y) + Math.abs(goal.x - current.x)) * 10\n}\n\n\nexport const Astar = (grid, start, end) => {\n    const PQ = new PriorityQueue()\n    let dict = {};\n    start.searched = true;\n    start.Gcost = 0;\n    start.Hcost = heuristic(end, start);\n    start.Fcost = start.Gcost + start.Hcost;\n    PQ.enqueue(start, start.Fcost);\n\n    while (PQ.items.length > 0) {\n        let curr = PQ.dequeue();\n        let current = curr.element;\n\n        if (current.y === end.y && current.x === end.x) {\n            console.log(\"Found\");\n            break;\n        } else {\n            let neighbours = findNeighbours(grid, [current.y, current.x]);\n\n            neighbours.forEach(el => {\n                let nb = grid[el[0]][el[1]];\n\n                if (nb.searched === false && nb.isWall === false) {\n                    nb.searched = true;\n                    nb.Gcost = current.Gcost + 10;\n                    nb.Hcost = heuristic(end, current);\n                    nb.Fcost = nb.weight + nb.Gcost + nb.Hcost;\n                    console.log(nb);\n                    PQ.enqueue(nb, nb.Fcost);\n                    dict[[el[0], el[1]]] = [current.y, current.x]\n                }\n            })\n        }\n    }\n\n    return dict;\n}\n\nexport const showAstar = (dict, start, end) => {\n    let curPos = end;\n    const result = [];\n\n    while (!equal(curPos, start)) {\n        result.push(curPos);\n        curPos = dict[curPos];\n    }\n\n    result.push(start);\n    result.reverse();\n    result.shift();\n    result.pop();\n\n    return result;\n}\n","import React, { useState, useEffect } from 'react'\nimport Node from './Node.jsx';\nimport './Pathfind.css';\nimport { BFS, drawPath } from '../Algorithms/Bfs';\nimport { Dijkstra, showDijkstra } from '../Algorithms/Dijkstra';\nimport { Astar, showAstar } from '../Algorithms/Astar';\nimport axios from 'axios';\nimport ClearIcon from '@material-ui/icons/Clear';\nimport DoneIcon from '@material-ui/icons/Done';\n\n\n//GLOBAL\nconst cols = 27;\nconst rows = 20;\nlet wall = [];\nlet sand = 0;\nlet sandSurface = [];\nlet ice = 0;\nlet iceSurface = [];\nlet snow = 0;\nlet snowSurface = [];\nlet tree = 0;\nlet treeSurface = [];\nlet mud = 0;\nlet mudSurface = [];\nlet mouseDown = 0;\n\n\nconst Pathfind = () => {\n    const [Grid, setGrid] = useState([]);\n    const [toggleBFS, setToggleBFS] = useState(0);\n    const [startCords, setStartCords] = useState([0, 0]);\n    const [endCords, setEndCords] = useState([rows - 1, cols - 1]);\n    const [wallCords, setWallCords] = useState([]);\n    const [deleteWallCords, setDeleteWallCords] = useState([]);\n    const [toggleDijkstra, setToggleDijkstra] = useState(0);\n    const [sandCords, setSandCords] = useState([]);\n    const [iceCords, setIceCords] = useState([]);\n    const [snowCords, setSnowCords] = useState([]);\n    const [treeCords, setTreeCords] = useState([]);\n    const [mudCords, setMudCords] = useState([]);\n    const [deleteSurface, setDeleteSurface] = useState([]);\n    const [allDeleted, setAllDeleted] = useState(0);\n    const [toggleAstar, setToggleAstar] = useState(0);\n    const [path, setPath] = useState(null);\n    const [sendData, setSendData] = useState(0);\n\n\n\n    const START_ROW = startCords[0];\n    const START_COL = startCords[1];\n    const END_ROW = endCords[0];\n    const END_COL = endCords[1];\n\n\n    useEffect(() => {\n        initializeGrid();\n    }, [toggleBFS, toggleDijkstra, toggleAstar, startCords, endCords, wallCords,\n        deleteWallCords, sandCords, iceCords, snowCords, treeCords, mudCords, deleteSurface, allDeleted]);\n\n    useEffect(() => {\n        sendPath();\n    }, [sendData]);\n\n    const sendPath = async() => {\n        console.log(\"funguje\");\n        let res = await axios.post('http://localhost:5000/sendPath', {\n            \"path\": path \n        })\n\n        console.log(res);\n\n        setPath(null)\n    }\n   \n\n    //Inicializace gridu\n    const initializeGrid = () => {\n        const grid = [];\n\n        //Naplneni gridu(grafu)\n        for (let i = 0; i < rows; i++) {\n            grid[i] = [];\n            for (let j = 0; j < cols; j++) {\n                grid[i][j] = new Spot(i, j);\n            }\n        }\n\n        //BFS algoritmus\n        if (toggleBFS === 1) {\n            BFSalg(grid);\n        }\n        //Dijkstruv algoritmus\n        if (toggleDijkstra === 1) {\n            DijkstraAlg(grid);\n        }\n        //Astart algoritmus\n        if (toggleAstar === 1) {\n            AstarAlg(grid);\n        } else {\n            setGrid(grid);\n            drawingWalls(grid);\n            drawingSurfaces(grid);\n        }\n    };\n\n\n    //Funkce na kresleni sten\n    const drawingWalls = (grid) => {\n        if (typeof wallCords.y === \"string\") {\n            wall.push(wallCords);\n\n            wall.forEach((el) => {\n                if (grid[el.y][el.x].isWall === false && el.isWall === true) {\n                    grid[el.y][el.x].isWall = true;\n                }\n\n                if (grid[el.y][el.x].isWall === true && el.isWall === false) {\n                    grid[el.y][el.x].isWall = false;\n                }\n            })\n        }\n    }\n\n\n    const drawingSurfaces = (grid) => {\n        if (typeof sandCords.y === \"string\") {\n            sandSurface.push(sandCords);\n\n            sandSurface.forEach((el) => {\n                if (grid[el.y][el.x].surfaceType === \"none\" && el.surfaceType !== \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                    grid[el.y][el.x].weight = el.weight;\n                    grid[el.y][el.x].Fcost = el.Fcost;\n                }\n\n                if (grid[el.y][el.x].surfaceType !== \"none\" && el.surfaceType === \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                }\n            })\n        }\n\n\n        if (typeof iceCords.y === \"string\") {\n            iceSurface.push(iceCords);\n\n            iceSurface.forEach((el) => {\n                if (grid[el.y][el.x].surfaceType === \"none\" && el.surfaceType !== \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                    grid[el.y][el.x].weight = el.weight;\n                    grid[el.y][el.x].Fcost = el.Fcost;\n                }\n\n                if (grid[el.y][el.x].surfaceType !== \"none\" && el.surfaceType === \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                }\n            })\n        }\n\n\n        if (typeof snowCords.y === \"string\") {\n            snowSurface.push(snowCords);\n\n            snowSurface.forEach((el) => {\n                if (grid[el.y][el.x].surfaceType === \"none\" && el.surfaceType !== \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                    grid[el.y][el.x].weight = el.weight;\n                    grid[el.y][el.x].Fcost = el.Fcost;\n                }\n\n                if (grid[el.y][el.x].surfaceType !== \"none\" && el.surfaceType === \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                }\n            })\n        }\n\n\n        if (typeof treeCords.y === \"string\") {\n            treeSurface.push(treeCords);\n\n            treeSurface.forEach((el) => {\n                if (grid[el.y][el.x].surfaceType === \"none\" && el.surfaceType !== \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                    grid[el.y][el.x].weight = el.weight;\n                    grid[el.y][el.x].Fcost = el.Fcost;\n                }\n\n                if (grid[el.y][el.x].surfaceType !== \"none\" && el.surfaceType === \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                }\n            })\n        }\n\n\n        if (typeof mudCords.y === \"string\") {\n            mudSurface.push(mudCords);\n\n            mudSurface.forEach((el) => {\n                if (grid[el.y][el.x].surfaceType === \"none\" && el.surfaceType !== \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                    grid[el.y][el.x].weight = el.weight;\n                    grid[el.y][el.x].Fcost = el.Fcost;\n                }\n\n                if (grid[el.y][el.x].surfaceType !== \"none\" && el.surfaceType === \"none\") {\n                    grid[el.y][el.x].surfaceType = el.surfaceType;\n                }\n            })\n        }\n    }\n\n\n    const findV2 = (arr, searchVal) => {\n        let output;\n        \n        arr.forEach((e) => {\n            e.forEach((e) => {\n                if(e.x === searchVal[1] && e.y === searchVal[0]) {\n                    output = e;\n                }\n            })\n        })\n    \n        return output;\n    }\n\n\n    const totalWeightFun = (grid, path, alg) => {\n        const totalWeightArr = [];\n\n        if(alg === \"Dijkstra\") {\n            path.forEach((e) => {\n                const found = findV2(grid, e);\n                totalWeightArr.push(found.weight);\n            })\n        } \n        \n        if(alg === \"Astar\") {\n            path.forEach((e) => {\n                const found = findV2(grid, e);\n                totalWeightArr.push(found.Fcost);\n            })\n        }\n\n        return totalWeightArr;\n    }\n\n\n    //Implementace BFS\n    const BFSalg = (grid) => {\n        drawingWalls(grid);\n\n        let start = grid[START_ROW][START_COL];\n        let end = grid[END_ROW][END_COL];\n\n        setGrid(grid);\n\n        const dict = BFS(grid, start, end);\n        const path = drawPath(dict, [start.y, start.x], [end.y, end.x]);\n        setPath(path);\n        console.log(path)\n\n        fillPath(grid, path);\n    }\n\n\n    //Implementace Dijkstry\n    const DijkstraAlg = (grid) => {\n        drawingWalls(grid);\n        drawingSurfaces(grid);\n\n        let start = grid[START_ROW][START_COL];\n        let end = grid[END_ROW][END_COL];\n\n        setGrid(grid);\n\n        const dict = Dijkstra(grid, start, end);\n        const path = showDijkstra(dict, [start.y, start.x], [end.y, end.x]);\n        setPath(path);\n\n        fillPath(grid, path);\n\n        const totalWeight = totalWeightFun(grid, path, \"Dijkstra\");\n        // console.log(totalWeight);\n    }\n\n    const AstarAlg = (grid) => {\n        drawingWalls(grid);\n        drawingSurfaces(grid);\n\n        let start = grid[START_ROW][START_COL];\n        let end = grid[END_ROW][END_COL];\n\n        setGrid(grid);\n\n        const dict = Astar(grid, start, end);\n        const path = showAstar(dict, [start.y, start.x], [end.y, end.x])\n        setPath(path);\n\n        fillPath(grid, path);\n\n        const totalWeight = totalWeightFun(grid, path,\"Astar\");\n        // console.log(totalWeight);\n    }\n\n\n    //Vytvoreni objektu pro kresleni sten\n    function wallSpot(y, x, isWall) {\n        this.y = y;\n        this.x = x;\n        this.isWall = isWall;\n    }\n\n\n    //Objekt porvrchu\n    function surfaceTypes(y, x, type, weight, Fcost) {\n        this.y = y;\n        this.x = x;\n        this.surfaceType = type;\n        this.weight = weight;\n        this.Fcost = Fcost;\n    }\n\n\n    // Vytvoreni objektu pro jednotlive spoty v gridu(grafu)\n    function Spot(y, x) {\n        this.y = y;\n        this.x = x;\n        this.isStart = this.y === START_ROW && this.x === START_COL;\n        this.isEnd = this.y === END_ROW && this.x === END_COL;\n        this.searched = false;\n        this.isPath = false;\n        this.isWall = false;\n        this.surfaceType = \"none\";\n        this.weight = 1;\n        this.Gcost = 0;\n        this.Hcost = 0;\n        this.Fcost = this.Gcost + this.Hcost;\n    };\n\n\n    //Nasteveni promene isPath v kazdem spotu ktery je soucasti cesty na true\n    const fillPath = (grid, path) => {\n        for (let i = 0; i < path.length; i++) {\n            grid[path[i][0]][path[i][1]].isPath = true;\n        }\n    }\n\n\n    const onDrop = (e) => {\n        e.preventDefault();\n        let data = e.dataTransfer.getData(\"text\");\n        const el = document.getElementById(data);\n\n        if (el.className === \"node node_start\") {\n            let scords = e.nativeEvent.srcElement.id;\n            let startcords = scords.split(\"-\");\n            setStartCords(startcords);\n        } else {\n            let ecords = e.nativeEvent.srcElement.id;\n            let endcords = ecords.split(\"-\");\n            setEndCords(endcords);\n        }\n\n        e.nativeEvent.target.draggable = el.draggable\n        e.nativeEvent.target.className = el.className\n\n        el.draggable = false;\n        el.className = \"node\";\n    }\n\n\n    const onDragOver = (e) => {\n        e.preventDefault();\n    }\n\n\n    const chosenSurface = (surface, surfacearr, weight, e, setSurfaceCords) => {\n        if (e.target.classList[1] === undefined) {\n            let memPos = e.target.id;\n            let pos = memPos.split(\"-\");\n            setSurfaceCords(new surfaceTypes(pos[0], pos[1], surface, weight));\n        }\n\n        if (e.target.classList[1] === \"node_\" + surface) {\n            let memPos = e.target.id;\n            let pos = memPos.split(\"-\");\n            setDeleteSurface(pos);\n\n            surfacearr.forEach((el) => {\n                if (el.y === pos[0] && el.x === pos[1]) {\n                    el.surfaceType = \"none\";\n                }\n            })\n        }\n    }\n\n\n    const onMouseDown = (e) => {\n        const cond = sand + ice + snow + tree + mud;\n        mouseDown = 1\n\n        if (cond > 0) {\n            switch (cond) {\n                case 1:\n                    chosenSurface(\"sand\", sandSurface, 5, e, setSandCords);\n                    break;\n                case 2:\n                    chosenSurface(\"ice\", iceSurface, 15, e, setIceCords);\n                    break;\n                case 3:\n                    chosenSurface(\"snow\", snowSurface, 10, e, setSnowCords)\n                    break;\n                case 4:\n                    chosenSurface(\"tree\", treeSurface, 3, e, setTreeCords);\n                    break;\n                case 5:\n                    chosenSurface(\"mud\", mudSurface, 7, e, setMudCords);\n                    break;\n                default:\n                    console.log(\"Nothing selected\");\n            }\n        } else {\n            if (e.target.classList[1] === undefined || e.target.classList[1] === \"node_\") {\n                let memPos = e.target.id;\n                let pos = memPos.split(\"-\");\n                setWallCords(new wallSpot(pos[0], pos[1], true));\n            }\n\n            if (e.target.classList[1] === \"node_wall\") {\n                let memPos = e.target.id;\n                let pos = memPos.split(\"-\");\n                setDeleteWallCords(pos);\n\n                wall.forEach((el) => {\n                    if (el.y === pos[0] && el.x === pos[1]) {\n                        el.isWall = false;\n                    }\n                })\n            }\n        }\n    }\n\n\n    const onSuerface = (e) => {\n        switch (e.target.name) {\n            case \"Sand\":\n                if(sand === 0) {\n                    sand = 1;\n                    e.target.className = \"usedSand\";\n                } else {\n                    sand = 0;\n                    e.target.className = \"sand\";\n                }       \n                break;\n            case \"Ice\":\n                if(ice === 0) {\n                    ice = 2;\n                    e.target.className = \"usedIce\";\n                } else {\n                    ice = 0;\n                    e.target.className = \"ice\";\n                }       \n                break;\n            case \"Snow\":\n                if(snow === 0) {\n                    snow = 3;\n                    e.target.className = \"usedSnow\";\n                } else {\n                    snow = 0;\n                    e.target.className = \"snow\";\n                }       \n                break;\n            case \"Tree\":\n                if(tree === 0) {\n                    tree = 4;\n                    e.target.className = \"usedTree\";\n                } else {\n                    tree = 0;\n                    e.target.className = \"tree\";\n                }       \n                break;\n            case \"Mud\":\n                if(mud === 0) {\n                    mud = 5;\n                    e.target.className = \"usedMud\";\n                } else {\n                    mud = 0;\n                    e.target.className = \"mud\";\n                }       \n                break;\n            default:\n                console.log(\"Nothing selected\");\n        }\n    }\n\n\n    const onMouseOver = (e) => {\n        const cond = sand + ice + snow + tree + mud;\n\n        if (mouseDown === 1) {\n            if (cond > 0) {\n                switch (cond) {\n                    case 1:\n                        chosenSurface(\"sand\", sandSurface, 5, e, setSandCords);\n                        break;\n                    case 2:\n                        chosenSurface(\"ice\", iceSurface, 15, e, setIceCords);\n                        break;\n                    case 3:\n                        chosenSurface(\"snow\", snowSurface, 10, e, setSnowCords);\n                        break;\n                    case 4:\n                        chosenSurface(\"tree\", treeSurface, 3, e, setTreeCords);\n                        break;\n                    case 5:\n                        chosenSurface(\"mud\", mudSurface, 7, e, setMudCords);\n                        break;\n                    default:\n                        console.log(\"Nothing selected\");\n                }\n            } else {\n                if (e.target.classList[1] === undefined || e.target.classList[1] === \"node_path\" || e.target.classList[1] === \"node_sand\"\n                    || e.target.classList[1] === \"node_ice\" || e.target.classList[1] === \"node_snow\" || e.target.classList[1] === \"node_tree\"\n                    || e.target.classList[1] === \"node_mud\") {\n                    let memPos = e.target.id;\n                    let pos = memPos.split(\"-\");\n                    setWallCords(new wallSpot(pos[0], pos[1], true));\n                }\n\n                if (e.target.classList[1] === \"node_wall\") {\n                    let memPos = e.target.id;\n                    let pos = memPos.split(\"-\");\n                    setDeleteWallCords(pos);\n\n                    wall.forEach((el) => {\n                        if (el.y === pos[0] && el.x === pos[1]) {\n                            el.isWall = false;\n                        }\n                    })\n                }\n            }\n        }\n    }\n\n\n    const onMouseUp = (e) => {\n        if (mouseDown === 1) {\n            mouseDown = 0\n        } else {\n            e.preventDefault();\n        }\n    }\n\n\n    const deleteAll = () => {\n        wall.forEach((el) => {\n            el.isWall = false;\n        })\n\n        sandSurface.forEach((el) => {\n            el.surfaceType = \"none\"\n        })\n\n\n        iceSurface.forEach((el) => {\n            el.surfaceType = \"none\"\n        })\n\n\n        snowSurface.forEach((el) => {\n            el.surfaceType = \"none\"\n        })\n\n\n        treeSurface.forEach((el) => {\n            el.surfaceType = \"none\"\n        })\n\n\n        mudSurface.forEach((el) => {\n            el.surfaceType = \"none\"\n        })\n\n        if (allDeleted === 0) {\n            setAllDeleted(1)\n        } else {\n            setAllDeleted(0)\n        }\n    }\n\n\n    const onSendData = () => {\n        if(sendData === 0) {\n            setSendData(1)\n        } else {\n            setSendData(0);\n        }\n    }\n\n\n    // Funkce na vykresleni gridu\n    const gridwithNode = (\n        <div className=\"Grid\" onDrop={(e) => (onDrop(e))} onDragOver={(e) => (onDragOver(e))}\n            onMouseDown={(e) => (onMouseDown(e))}\n            onMouseOver={(e) => (onMouseOver(e))}\n            onMouseUp={(e) => (onMouseUp(e))}\n        >\n            {\n                Grid.map((row, rowIndex) => {\n                    return (\n                        <div key={rowIndex} className='rowWrapper'>\n                            {row.map((col, colIndex) => {\n                                const { isStart, isEnd, searched, isPath, isWall, surfaceType } = col;\n                                return (\n                                    <Node key={colIndex}\n                                    isPath={isPath}\n                                    isWall={isWall}\n                                    isStart={isStart}\n                                    isEnd={isEnd}\n                                    searched={searched}\n                                    row={rowIndex}\n                                    col={colIndex}\n                                    surfaceType={surfaceType}\n                                    />\n                                    )\n                                })}\n                        </div>\n                    )\n                })\n            }\n        </div >\n    )\n    \n    \n    return (\n        <div className='Wrapper'>\n            <h1>Nejkratší cesta přes 2D pole</h1>\n            {/* Vykresleni gridu */}\n            {gridwithNode}\n            <div className=\"algButtons\">\n                <div className=\"BFSbuttons\">\n                    <button className=\"bfsOn\" onClick={() => setToggleBFS(1)}>Zapni BFS</button>\n                    <button className=\"bfsOff\" onClick={() => {if(toggleBFS === 1) {setToggleBFS(0)}}}>Vypni BFS</button>\n                </div>\n                <div className=\"dijkstraButtons\">\n                    <button className=\"dijkstraOn\" onClick={() => setToggleDijkstra(1)}>Zapni Dijkstru</button>\n                    <button className=\"dijkstraOff\" onClick={() => {if(toggleDijkstra === 1) {setToggleDijkstra(0)}}}>Vypni Dijkstru</button>\n                </div>\n                <div className=\"astarButtons\">\n                    <button className=\"astarOn\" onClick={() => setToggleAstar(1)}>Zapni Astar</button>\n                    <button className=\"astarOff\" onClick={() => {if(toggleAstar === 1) {setToggleAstar(0)}}}>Vypni Astar</button>\n                </div>\n            </div>\n            <div className=\"utilityButtons\">\n                <div className=\"surfaceButtons\">\n                    <button className=\"sand\" onClick={(e) => onSuerface(e)} name=\"Sand\">Písek</button>\n                    <button className=\"ice\" onClick={(e) => onSuerface(e)} name=\"Ice\">Led</button>\n                    <button className=\"snow\" onClick={(e) => onSuerface(e)} name=\"Snow\">Sníh</button>\n                    <button className=\"tree\" onClick={(e) => onSuerface(e)} name=\"Tree\">Stromy</button>\n                    <button className=\"mud\" onClick={(e) => onSuerface(e)} name=\"Mud\">Bahno</button>\n                </div>\n                <div className=\"delButtons\">\n                    <button className=\"deleteAll\" onClick={() => { deleteAll() }}>Delete ALL <ClearIcon className=\"clearIcon\"/></button>\n                    <button className=\"sendData\" onClick={() => { onSendData() }}>Send Data <DoneIcon className=\"doneIcon\"/></button>\n                </div>\n            </div>\n        </div>\n    )\n}\n\nexport default Pathfind\n","import React from 'react';\nimport './App.css';\nimport Pathfinding from './components/Pathfind.jsx'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Pathfinding />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App.jsx';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}